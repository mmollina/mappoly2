#' Assign Markers to Linkage Groups
#'
#' This function identifies linkage groups of markers using the results
#' from two-point (pairwise) analysis in a \code{mappoly2.data} or \code{mappoly2.sequence} object.
#'
#' @param x A \code{mappoly2.data} object that contains recombination fraction information.
#' @param expected.groups The expected number of linkage groups (e.g., chromosomes)
#' for the species, if known. This parameter is mandatory unless \code{inter} is set to \code{TRUE}.
#' @param inter Logical; if \code{TRUE}, the function allows interactive determination of
#' the expected number of groups by plotting a dendrogram (default is \code{TRUE}).
#' @param comp.mat Logical; if \code{TRUE}, displays a comparison matrix between the
#' reference-based and linkage-based groupings if chromosome information is available (default is \code{FALSE}).
#' @param LODweight Logical; if \code{TRUE}, clustering is weighted by
#' the square of the LOD score (default is \code{FALSE}).
#'
#' @return An object of class \code{mappoly2.group}, which includes:
#' \describe{
#'   \item{hc.snp}{A hierarchical clustering object generated by UPGMA or average method.}
#'   \item{expected.groups}{The specified or interactively determined number of expected linkage groups.}
#'   \item{groups.snp}{The assigned linkage groups for each marker.}
#'   \item{seq.vs.grouped.snp}{Comparison matrix between genomic group information and the assigned groups, if \code{comp.mat} is \code{TRUE}.}
#' }
#'
#' @details The function first validates the input object and then performs hierarchical clustering on the recombination fraction matrix.
#' If \code{LODweight} is \code{TRUE}, the clustering is weighted by the square of the LOD scores.
#' The function can interactively determine the number of expected groups and allows users to confirm or adjust this number.
#' A dendrogram is plotted for visual inspection. The function also optionally compares the assigned groups with genomic group information.
#'
#'
#' @author Marcelo Mollinari, \email{mmollin@ncsu.edu}
#' @importFrom graphics abline pie
#' @importFrom stats as.dendrogram as.dist cutree hclust lm predict quantile rect.hclust
#' @importFrom dendextend color_branches
#' @export
group <- function(x = NULL,
                  expected.groups = NULL,
                  inter = TRUE,
                  comp.mat = FALSE,
                  LODweight = FALSE)
{
  assert_that(has.mappoly2.rf(x))
  mrk.id <- intersect(x$screened.data$mrk.names, colnames(x$pairwise.rf$rec.mat))
  MSNP <- x$pairwise.rf$rec.mat[mrk.id, mrk.id]
  mn <- x$chrom[mrk.id]
  mn[is.na(mn)] <- "NoChr"
  dimnames(MSNP) <- list(mn, mn)
  diag(MSNP) <- 0
  MSNP[is.na(MSNP)] <- .5
  if(LODweight){
    Mlod <- x$pairwise$lod.mat^2
    Mlod[is.na(Mlod)] <- 10e-5
    hc.snp <- hclust(as.dist(MSNP), method="ward.D2", members=apply(Mlod, 1, mean, na.rm = TRUE))
  } else {
    hc.snp <- hclust(as.dist(MSNP), method = "average")
  }
  ANSWER <- "flag"
  if(interactive() && inter)
  {
    dend.snp <- as.dendrogram(hc.snp)
    while(substr(ANSWER, 1, 1) != "y" && substr(ANSWER, 1, 1) != "yes" && substr(ANSWER, 1, 1) != "Y" && ANSWER  != "")
    {
      if(is.null(expected.groups))
        expected.groups <- as.numeric(readline("Enter the number of expected groups: "))

      ## Plot dendrogram
      op <- par(lwd=1.5)
      on.exit(par(op))
      dend1 <- dendextend::color_branches(dend.snp, k = expected.groups, col = mp_pal(expected.groups), border = "black")
      plot(dend1, leaflab = "none")
      z <- list(colnames(MSNP))
      if(expected.groups != 1){
        par(lwd=4)
        z <- rect.hclust(hc.snp, k = expected.groups)
        par(lwd=1)
      }
      groups.snp  <- cutree(tree = hc.snp, k = expected.groups)
      xy <- sapply(z, length)
      xt <- as.numeric(cumsum(xy)-ceiling(xy/2))
      yt <- .1
      points(x = xt, y = rep(yt, length(xt)), cex = 6, pch = 20, col = "lightgray")
      text(x = xt, y = yt, labels = pmatch(xy, table(groups.snp, useNA = "ifany")), adj = .5)

      groups.snp  <- cutree(tree = hc.snp, k = expected.groups)
      ANSWER <- readline("Enter 'Y/n' to proceed or update the number of expected groups: ")
      if(substr(ANSWER, 1, 1)  ==  "n" | substr(ANSWER, 1, 1)  ==  "no" | substr(ANSWER, 1, 1)  ==  "N")
        stop("Function halted.")
      if(substr(ANSWER, 1, 1) != "y" && substr(ANSWER, 1, 1) != "yes" && substr(ANSWER, 1, 1) != "Y" && ANSWER  != "")
        expected.groups <- as.numeric(ANSWER)
    }
  }
  if(is.null(expected.groups))
    stop("Inform the 'expected.groups' or use 'inter = TRUE'")
  # Distribution of SNPs into linkage groups
  seq.vs.grouped.snp <- NULL
  if(all(unique(mn)  ==  "NoChr") & comp.mat)
  {
    comp.mat <- NA
    seq.vs.grouped.snp <- NA
    warning("There is no physical reference to generate a comparison matrix")
  }
  groups.snp  <- cutree(tree = hc.snp, k = expected.groups)

  if(comp.mat){
    seq.vs.grouped.snp <- matrix(0, expected.groups, length(na.omit(unique(mn))),
                                 dimnames = list(1:expected.groups, na.omit(unique(mn))))
    for(i in 1:expected.groups)
    {
      u <- table(names(which(groups.snp == i)))
      seq.vs.grouped.snp[i,names(u)] <- u
    }
    if(length(seq.vs.grouped.snp) != 1){
      idtemp2 <- unique(apply(seq.vs.grouped.snp, 1, which.max))
      b <- setdiff(1:(ncol(seq.vs.grouped.snp)), idtemp2)
      if(length(b)!=0){
        idtemp2 <- c(idtemp2, b)
        seq.vs.grouped.snp <- cbind(seq.vs.grouped.snp[,idtemp2])
        cnm <- colnames(seq.vs.grouped.snp)
        colnames(seq.vs.grouped.snp) <- cnm
        seq.vs.grouped.snp <- cbind(seq.vs.grouped.snp, apply(seq.vs.grouped.snp, 1, sum))
        seq.vs.grouped.snp <- rbind(seq.vs.grouped.snp, apply(seq.vs.grouped.snp, 2, sum))
        colnames(seq.vs.grouped.snp)[ncol(seq.vs.grouped.snp)] <- "Total"
        rownames(seq.vs.grouped.snp)[nrow(seq.vs.grouped.snp)] <- "Total"
      }
    }
  } else {
    seq.vs.grouped.snp <- NULL
  }
  names(groups.snp) <- mrk.id
  return(structure(list(hc.snp = hc.snp,
                        expected.groups = expected.groups,
                        groups.snp = groups.snp,
                        seq.vs.grouped.snp = seq.vs.grouped.snp,
                        data = x), class = "mappoly2.group"))
}

