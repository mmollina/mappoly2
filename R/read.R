#' Read Genetic Marker Data from a CSV File
#'
#' This function reads genetic marker data from a comma-separated values (CSV)
#' file and returns an object of class \code{mappoly2.data}.
#'
#' The CSV file should have rows representing markers, with the first row serving
#' as the header. The first seven columns are expected to contain the marker
#' names, the dosages in parents 1 and 2, chromosome information (e.g.,
#' chromosome, scaffold, contig), the position of the marker within the
#' sequence, and the alternate and reference alleles, if available.
#' In the absence of allele information, the values should be NA. The remaining
#' columns should contain the dosage for each member of the full-sib population.
#'  See the \code{Examples} section for a tetraploid example.
#'
#' @param file.in A character string specifying the name or full path to the
#' input file.
#'
#' @param ploidy.p1 The ploidy level of parent 1.
#'
#' @param ploidy.p2 The ploidy level of parent 2.
#'
#' @param name.p1 The name of parent 1.
#'
#' @param name.p2 The name of parent 2.
#'
#' @param filter.non.conforming Logical. If \code{TRUE} (default), data points
#' with unexpected genotypes (e.g., double reduction) are converted to 'NA'.
#' Refer to the \code{\link[mappoly]{segreg_poly}} function for details on
#' expected genotype classes and their frequencies.
#'
#' @param filter.redundant Logical. If \code{TRUE} (default), removes redundant
#' markers during map construction, retaining annotations for export in the
#' final map.
#'
#' @param verbose Logical. If \code{TRUE} (default), displays progress updates;
#' if \code{FALSE}, no output is provided.
#'
#'
#' @return Returns an object of class \code{mappoly2.data} containing a
#' list with the following components:
#' \describe{
#'   \item{ploidy.p1}{Ploidy level of the first parent.}
#'   \item{ploidy.p2}{Ploidy level of the second parent.}
#'   \item{n.ind}{Number of individuals.}
#'   \item{n.mrk}{Total number of markers.}
#'   \item{ind.names}{Names or identifiers of the individuals.}
#'   \item{mrk.names}{Names or identifiers of the genetic markers.}
#'   \item{name.p1}{Name or identifier of the first parent.}
#'   \item{name.p2}{Name or identifier of the second parent.}
#'   \item{dosage.p1}{Dosage for the first parent.}
#'   \item{dosage.p2}{Dosage for the second parent.}
#'   \item{chrom}{Chromosome numbers for all markers.}
#'   \item{genome.pos}{Physical positions on the genome for the genetic markers.}
#'   \item{ref}{Reference DNA sequence data for the genetic markers.}
#'   \item{alt}{Alternate DNA sequence data for the genetic markers.}
#'   \item{all.mrk.depth}{Depth of coverage for all genetic markers. NULL when using CSV input files.}
#'   \item{geno.dose}{A matrix containing the dosage for each marker (rows) for each individual (columns).}
#'   \item{redundant}{A list of non-redundant markers and their equivalent redundant markers if \code{filter.redundant} is TRUE.}
#'   \item{QAQC.values}{A list containing quality assurance and quality control values with the following components:
#'     \describe{
#'       \item{$markers}{A data frame with statistics for each marker, including `miss` (missing data rate), `chisq.pval` (chi-squared test p-value), and `read.depth` (read depth).}
#'       \item{$individuals}{A data frame with statistics for each individual, including `miss` (missing data rate) and `full.sib` (indicator of non-belonging to the analyzed bi-parental cross, generated by \code{\link[mappoly]{filter_individuals}}).}
#'     }
#'   }
#' }
#' @examples
#' \donttest{
#' tempfl <- list.files(system.file('extdata', package = 'mappoly2'),
#'                      full.names = TRUE)
#' alfalfa.bc <- read_geno_csv(file.in = tempfl,
#'                             ploidy.p1 = 4,
#'                             name.p1 = "I195",
#'                             name.p2 = "F1.85.209")
#' print(alfalfa.bc, detailed = TRUE)
#' plot(alfalfa.bc)
#' }
#' @author Marcelo Mollinari, \email{mmollin@ncsu.edu}
#' @importFrom grDevices rgb
#' @importFrom stats na.omit
#' @importFrom utils read.csv
#' @importFrom assertthat is.readable
#' @export
read_geno_csv <- function(file.in,
                          ploidy.p1,
                          ploidy.p2 = ploidy.p1,
                          name.p1 = NULL,
                          name.p2 = NULL,
                          filter.non.conforming = TRUE,
                          filter.redundant = TRUE,
                          verbose = TRUE) {
  assert_that(is.readable(file.in))
  dat <- read.csv(file = file.in,
                  header = TRUE,
                  stringsAsFactors = FALSE)
  return(table_to_mappoly(dat,
                          ploidy.p1,
                          ploidy.p2,
                          name.p1,
                          name.p2,
                          filter.non.conforming,
                          filter.redundant,
                          verbose))
}


#' Read VCF File for Genetic Marker Data
#'
#' This function reads genetic marker data from a Variant Call Format (VCF) file and returns an object of class \code{mappoly2.data}.
#'
#' This function supports VCF files of version 4.0 or higher.
#'
#' @param file.in A character string specifying the name or full path of the input file containing the data in VCF format.
#' @param ploidy.p1 An integer indicating the ploidy level of parent 1.
#' @param ploidy.p2 An integer indicating the ploidy level of parent 2. Defaults to the value of \code{ploidy.p1}.
#' @param name.p1 A character string containing the name of parent 1.
#' @param name.p2 A character string containing the name of parent 2.
#' @param name.offspring A character vector containing the names of the offspring. If \code{NULL}, all subjects except \code{name.p1} and \code{name.p2} will be considered as offspring.
#' @param filter.non.conforming Logical, if \code{TRUE} (default), converts data points with unexpected genotypes to 'NA'. See \code{\link[mappoly]{segreg_poly}} for details on expected classes and frequencies.
#' @param filter.redundant Logical, if \code{TRUE} (default), removes redundant markers during map construction, keeping them annotated for export to the final map.
#' @param verbose Logical, if \code{TRUE} (default), displays progress information.
#' @param min.gt.depth An integer specifying the minimum genotype depth to retain information. Values below \code{min.gt.depth} are replaced with \code{NA} (default = 0).
#' @param min.av.depth An integer specifying the minimum average depth to retain markers (default = 0).
#' @param max.missing A numeric value specifying the maximum proportion of missing data allowed to retain markers (range = 0-1; default = 1).
#'
#' @return An object of class \code{mappoly2.data} containing the following components:
#' \describe{
#'   \item{ploidy.p1}{Ploidy level of parent 1.}
#'   \item{ploidy.p2}{Ploidy level of parent 2.}
#'   \item{n.ind}{Number of individuals.}
#'   \item{n.mrk}{Total number of markers.}
#'   \item{ind.names}{Names of the individuals.}
#'   \item{mrk.names}{Names of the genetic markers.}
#'   \item{name.p1}{Name of parent 1.}
#'   \item{name.p2}{Name of parent 2.}
#'   \item{dosage.p1}{Dosage information for parent 1.}
#'   \item{dosage.p2}{Dosage information for parent 2.}
#'   \item{chrom}{Chromosome numbers for all markers.}
#'   \item{genome.pos}{Physical positions of the genetic markers on the genome.}
#'   \item{ref}{Reference DNA sequence data for the genetic markers.}
#'   \item{alt}{Alternate DNA sequence data for the genetic markers.}
#'   \item{all.mrk.depth}{Depth of coverage for all genetic markers.}
#'   \item{geno.dose}{A matrix of dosage information for each marker (rows) and each individual (columns).}
#'   \item{redundant}{A list of non-redundant markers and their equivalent redundant markers if \code{filter.redundant} is TRUE.}
#'   \item{QAQC.values}{Quality assurance and quality control values:
#'     \describe{
#'       \item{markers}{A data frame with statistics for each marker, including `miss` (missing data rate), `chisq.pval` (chi-squared test p-value), and `read.depth` (read depth).}
#'       \item{individuals}{A data frame with statistics for each individual, including `miss` (missing data rate) and `full.sib` (indicator of non-belonging to the analyzed bi-parental cross, generated by \code{\link[mappoly]{filter_individuals}}).}
#'     }
#'   }
#' }
#'
#' @examples
#' \donttest{
#' ## Hexaploid sweetpotato: Subset of chromosome 3
#' fl <- "https://github.com/mmollina/MAPpoly_vignettes/raw/master/data/sweet_sample_ch3.vcf.gz"
#' tempfl <- tempfile(pattern = 'chr3_', fileext = '.vcf.gz')
#' download.file(fl, destfile = tempfl)
#' dat.dose.vcf <- read_vcf(file.in = tempfl, ploidy.p1 = 6, name.p1 = "PARENT1", name.p2 = "PARENT2", min.av.depth = 20)
#' print(dat.dose.vcf)
#' plot(dat.dose.vcf)
#' }
#'
#' @references Gabriel Gesteira, \email{gdesiqu@ncsu.edu}, Marcelo Mollinari, \email{mmollin@ncsu.edu}
#'
#' @export read_vcf
read_vcf <- function(file.in,
                     ploidy.p1,
                     ploidy.p2 = ploidy.p1,
                     name.p1,
                     name.p2,
                     name.offspring = NULL,
                     filter.non.conforming = TRUE,
                     filter.redundant = TRUE,
                     verbose = TRUE,
                     min.gt.depth = 0,
                     min.av.depth = 0,
                     max.missing = 1) {
  # Check if the input file is readable
  assert_that(is.readable(file.in))

  # Validate ploidy levels
  mappoly2:::has.adequate.ploidy(ploidy.p1)
  mappoly2:::has.adequate.ploidy(ploidy.p2)

  # Expected ploidy level for offspring
  expect.ploidy.offspring <- (ploidy.p1 + ploidy.p2) / 2

  # Get the full path and size of the input file
  input.file <- normalizePath(file.in)
  input.size <- file.size(file.in) / 1024000  # File size in MB

  # Warn if the file size is too large
  if (verbose && input.size > 3000) {
    warning("Your VCF file is greater than 3 GB. Check for available RAM memory.")
  }

  if (verbose) cat("Reading data...\n")

  # Read the VCF file
  input.data <- vcfR::read.vcfR(file.in, verbose = verbose)

  # Get individual names from the genotype matrix
  ind.names <- colnames(input.data@gt)[-1]

  # Check if parent names are in the dataset
  if (!name.p1 %in% ind.names) stop(name.p1, " is not in the dataset")
  if (!name.p2 %in% ind.names) stop(name.p2, " is not in the dataset")

  # Determine offspring names
  if (is.null(name.offspring)) name.offspring <- setdiff(ind.names, c(name.p1, name.p2))
  name.offspring <- intersect(name.offspring, ind.names)
  if (length(name.offspring) == 0) stop("The provided names of the offspring individuals are not found in the dataset")

  # Get number of markers and individuals
  n.mrk <- nrow(input.data@gt)
  n.ind <- length(name.offspring)

  # Get marker names and chromosome information
  mrk.names <- mrk.names.all <- input.data@fix[,"ID"]
  chrom <- input.data@fix[,"CHROM"]
  genome.pos <- as.numeric(input.data@fix[,"POS"])

  # Handle unnamed markers
  if (any(is.na(unique(mrk.names)))) {
    if (verbose) cat("No named markers. Using genome information instead.\n")
    no_name <- sum(is.na(mrk.names))
    mrk.names[which(is.na(mrk.names))] <- paste0(chrom[which(is.na(mrk.names))], "_", genome.pos[which(is.na(mrk.names))])
  }

  # Set names for chromosome and position vectors
  names(chrom) <- mrk.names
  names(genome.pos) <- mrk.names

  # Get reference and alternate alleles
  seq.ref <- input.data@fix[,"REF"]
  names(seq.ref) <- mrk.names
  seq.alt <- input.data@fix[,"ALT"]
  names(seq.alt) <- mrk.names

  if (verbose) cat("Processing genotypes...")

  # Define positions of GT (genotype) and DP (depth) fields
  cname <- which(unlist(strsplit(unique(input.data@gt[,1]), ":")) == "GT")[1]
  dname <- which(unlist(strsplit(unique(input.data@gt[,1]), ":")) == "DP")[1]

  # Get ploidy levels and depths for all individuals
  offspring.ploidy <- mappoly2:::.vcf_get_ploidy(input.data@gt[,name.offspring], cname)
  geno.depth <- mappoly2:::.vcf_get_depth(input.data@gt[,c(name.p1, name.p2, name.offspring)], dname)
  unique.offspring.ploidy <- unique(c(offspring.ploidy))

  # Transform genotype data to dosage information
  geno.dose <- mappoly2:::.vcf_transform_dosage(input.data@gt[,c(name.p1, name.p2, name.offspring)], cname)
  dimnames(geno.depth) <- dimnames(geno.dose) <- list(mrk.names, c(name.p1, name.p2, name.offspring))
  geno.dose[which(geno.dose == -1)] <- NA

  if (verbose) cat("Done!\n")

  # Check if the observed ploidy in the offspring matches the expected ploidy
  if (!(expect.ploidy.offspring %in% unique.offspring.ploidy)) stop("Observed ploidy in the offspring differs from the expected ploidy")

  # Update marker information based on thresholds
  dif_ploidy <- which(rowSums(offspring.ploidy == expect.ploidy.offspring) == n.ind)
  all_mrk_depth <- rowMeans(geno.depth)
  av_depth <- which(all_mrk_depth >= min.av.depth)
  max_miss <- which(rowSums(is.na(geno.dose)) / dim(geno.dose)[2] <= max.missing)
  selected_markers <- mrk.names[intersect(intersect(dif_ploidy, av_depth), max_miss)]

  # Filter genotype and depth data
  geno.dose <- geno.dose[selected_markers, ]
  geno.depth <- geno.depth[selected_markers, ]
  geno.dose[which(geno.depth < min.gt.depth)] <- NA
  all_mrk_depth <- all_mrk_depth[selected_markers]
  n.mrk <- nrow(geno.dose)
  selected_markers <- names(which(apply(geno.dose[, c(name.p1, name.p2), drop = FALSE], 1, function(x) all(!is.na(x)))))

  # Create a data frame for the selected markers
  dat <- data.frame(snp_id = selected_markers,
                    P1 = as.integer(geno.dose[selected_markers, name.p1]),
                    P2 = as.integer(geno.dose[selected_markers, name.p2]),
                    chrom = chrom[selected_markers],
                    genome_pos = genome.pos[selected_markers],
                    ref = seq.ref[selected_markers],
                    alt = seq.alt[selected_markers],
                    geno.dose[selected_markers, name.offspring, drop = FALSE])

  # Convert the data frame to a mappoly object
  out <- mappoly2:::table_to_mappoly(dat,
                                     ploidy.p1,
                                     ploidy.p2,
                                     name.p1,
                                     name.p2,
                                     filter.non.conforming,
                                     filter.redundant,
                                     verbose)

  # Add read depth to the QAQC values
  out$QAQC.values$markers$read.depth <- all_mrk_depth[rownames(out$QAQC.values$markers)]

  return(out)
}




#' Conversion of data.frame to mappoly.data
#'
#' @param void internal function to be documented
#' @keywords internal
table_to_mappoly <- function(dat,
                             ploidy.p1,
                             ploidy.p2,
                             name.p1 = NULL,
                             name.p2 = NULL,
                             filter.non.conforming = TRUE,
                             filter.redundant = TRUE,
                             verbose = TRUE) {

  # Removing markers with missing data points for parents
  dat <- dat[apply(dat[, 2:3], 1, function(x) !any(is.na(x))), ]

  # Get number of individuals
  n.ind <- ncol(dat) - 7

  # Get number of markers
  n.mrk <- nrow(dat)

  # Get marker names
  mrk.names.raw <- mrk.names <- as.character(dat[, 1, drop = TRUE])

  # Get individual's names
  ind.names <- colnames(dat)[-c(1:7)]

  # Get parent's names
  if (is.null(name.p1)) {
    name.p1 <- colnames(dat)[2]
  }
  if (is.null(name.p2)) {
    name.p2 <- colnames(dat)[3]
  }

  # Get dosage in parent P1
  dosage.p1 <- as.integer(dat[, 2, drop = TRUE])

  # Get dosage in parent P2
  dosage.p2 <- as.integer(dat[, 3, drop = TRUE])

  # Polymorphic markers
  d.p1 <- abs(abs(dosage.p1 - (ploidy.p1 / 2)) - (ploidy.p1 / 2))
  d.p2 <- abs(abs(dosage.p2 - (ploidy.p2 / 2)) - (ploidy.p2 / 2))
  id <- d.p1 + d.p2 != 0

  # Markers with parental dosages less or equal than ploidy levels
  id <- d.p1 <= ploidy.p1 & d.p2 <= ploidy.p2 & id

  # Get chromosome info
  chrom <- as.character(dat[, 4, drop = TRUE])
  chrom[embedded_to_numeric(chrom) == 0] <- "NoChr"
  chrom[is.na(chrom)] <- "NoChr"

  # Get sequence position info
  genome.pos <- as.numeric(dat[, 5, drop = TRUE])

  ref <- as.character(dat[, 6, drop = TRUE])
  alt <- as.character(dat[, 7, drop = TRUE])
  names(ref) <- names(alt) <- names(genome.pos) <- names(chrom) <- names(dosage.p2) <- names(dosage.p1) <- mrk.names

  if (verbose) {
    cat("Reading the following data:")
    txt <- list(
      paste0("    Ploidy level of ", name.p1, ":"),
      paste0("    Ploidy level of ", name.p2, ":"),
      paste0("    No. individuals:"),
      paste0("    No. markers:"),
      paste0("    No. informative markers:")
    )
    n <- sapply(txt, nchar)
    for (i in 1:length(txt)) {
      txt[[i]] <- paste(txt[[i]], paste0(rep(" ", max(n) - n[i]), collapse = ""))
    }
    cat("\n", txt[[1]], ploidy.p1)
    cat("\n", txt[[2]], ploidy.p2)
    cat("\n", txt[[3]], n.ind)
    cat("\n", txt[[4]], n.mrk)
    cat("\n ", txt[[5]], " ", sum(id), " (", round(100 * sum(id) / n.mrk, 1), "%)", sep = "")
    cat("\n     ---")
    if (any(!is.na(chrom))) {
      cat("\n     This dataset contains chromosome information.")
    }
    if (any(!is.na(genome.pos))) {
      cat("\n     This dataset contains position information.")
    }
    cat("\n     ")
  }

  # Get genotypic info
  geno.dose <- as.matrix(dat[, -c(1:7), drop = FALSE])
  dimnames(geno.dose) <- list(mrk.names, ind.names)

  # Replacing non-conforming values with NA
  geno.dose[geno.dose > ploidy.p1/2 + ploidy.p2/2] <- NA

  geno.dose <- geno.dose[id, , drop = FALSE]
  res <- structure(
    list(ploidy.p1 = ploidy.p1,
         ploidy.p2 = ploidy.p2,
         n.ind = n.ind,
         n.mrk = sum(id),
         ind.names = ind.names,
         mrk.names = mrk.names[id],
         name.p1 = name.p1,
         name.p2 = name.p2,
         dosage.p1 = dosage.p1[id],
         dosage.p2 = dosage.p2[id],
         chrom = chrom[id],
         genome.pos = genome.pos[id],
         ref = ref,
         alt = alt,
         all.mrk.depth = NULL,
         geno.dose = geno.dose,
         redundant = NULL,
         QAQC.values = NULL),
    class = c("mappoly2.data")
  )

  # Screening non-conforming markers
  if (filter.non.conforming) {
    if (verbose) cat(" -->  Filtering non-conforming markers.\n     ")
    res <- filter_non_conforming_classes(res)
  }
  # Screening redundant markers
  if(filter.redundant){
    if (verbose) cat(" -->  Filtering markers with redundant information.\n     ")
    res <- filter_redundant(res)
  }
  res$QAQC.values <- .setQAQC(id.mrk = res$mrk.names,
                              id.ind = res$ind.names,
                              miss.mrk = apply(res$geno.dose, 1, function(x) sum(is.na(x)))/res$n.ind,
                              miss.ind = apply(res$geno.dose, 2, function(x) sum(is.na(x)))/res$n.mrk,
                              chisq.pval = suppressWarnings(mappoly_chisq_test(res)))
  if(verbose) cat("----------------------------------\n")
  return(res)
}
