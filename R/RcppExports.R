# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

calc_haploprob_biallelic <- function(PH, G, pedigree, rf, err) {
    .Call('_mappoly2_calc_haploprob_biallelic', PACKAGE = 'mappoly2', PH, G, pedigree, rf, err)
}

calc_haploprob_biallelic_single <- function(PH, G, rf, err) {
    .Call('_mappoly2_calc_haploprob_biallelic_single', PACKAGE = 'mappoly2', PH, G, rf, err)
}

find_valid_permutations <- function(H, d, x) {
    .Call('_mappoly2_find_valid_permutations', PACKAGE = 'mappoly2', H, d, x)
}

vs_inserted_mrk <- function(PH, G, pedigree, M, idx) {
    .Call('_mappoly2_vs_inserted_mrk', PACKAGE = 'mappoly2', PH, G, pedigree, M, idx)
}

vs_biallelic_error <- function(PH, G, pedigree, err, logatithm) {
    .Call('_mappoly2_vs_biallelic_error', PACKAGE = 'mappoly2', PH, G, pedigree, err, logatithm)
}

est_hmm_map_biallelic_insert_marker <- function(PH, G, pedigree, M, rf, idx, verbose, detailed_verbose, tol, ret_H0) {
    .Call('_mappoly2_est_hmm_map_biallelic_insert_marker', PACKAGE = 'mappoly2', PH, G, pedigree, M, rf, idx, verbose, detailed_verbose, tol, ret_H0)
}

est_hmm_map_biallelic <- function(PH, G, pedigree, rf, err, verbose, detailed_verbose, tol, ret_H0) {
    .Call('_mappoly2_est_hmm_map_biallelic', PACKAGE = 'mappoly2', PH, G, pedigree, rf, err, verbose, detailed_verbose, tol, ret_H0)
}

est_hmm_map_biallelic_single <- function(PH, G, rf, err, verbose, detailed_verbose, tol, ret_H0) {
    .Call('_mappoly2_est_hmm_map_biallelic_single', PACKAGE = 'mappoly2', PH, G, rf, err, verbose, detailed_verbose, tol, ret_H0)
}

pairwise_rf_estimation_disc_rcpp <- function(mrk_pairs_R, ploidy_p1_R, ploidy_p2_R, geno_R, dose_p1_R, dose_p2_R, count_vector_R, count_matrix_phases_R, count_matrix_rownames_R, count_matrix_number_R, count_matrix_pos_R, count_matrix_length_R, tol_R) {
    .Call('_mappoly2_pairwise_rf_estimation_disc_rcpp', PACKAGE = 'mappoly2', mrk_pairs_R, ploidy_p1_R, ploidy_p2_R, geno_R, dose_p1_R, dose_p2_R, count_vector_R, count_matrix_phases_R, count_matrix_rownames_R, count_matrix_number_R, count_matrix_pos_R, count_matrix_length_R, tol_R)
}

twopt_phasing_cpp <- function(mrk_id, ploidy, dose_vec, S, max_conf_number, verbose) {
    .Call('_mappoly2_twopt_phasing_cpp', PACKAGE = 'mappoly2', mrk_id, ploidy, dose_vec, S, max_conf_number, verbose)
}

phasing_one <- function(mrk_id, dose_vec, S, InitPh, verbose) {
    .Call('_mappoly2_phasing_one', PACKAGE = 'mappoly2', mrk_id, dose_vec, S, InitPh, verbose)
}

est_hmm_map_biallelic_log_implementation <- function(PH, G, pedigree, rf, err, verbose, detailed_verbose, tol, ret_H0) {
    .Call('_mappoly2_est_hmm_map_biallelic_log_implementation', PACKAGE = 'mappoly2', PH, G, pedigree, rf, err, verbose, detailed_verbose, tol, ret_H0)
}

#' Mendelian segregation
NULL

segreg_poly <- function(ploidy_p1, ploidy_p2, d_p1, d_p2) {
    .Call('_mappoly2_segreg_poly', PACKAGE = 'mappoly2', ploidy_p1, ploidy_p2, d_p1, d_p2)
}

mappoly_chisq_test <- function(input_data) {
    .Call('_mappoly2_mappoly_chisq_test', PACKAGE = 'mappoly2', input_data)
}

filter_non_conforming_classes <- function(input_data) {
    .Call('_mappoly2_filter_non_conforming_classes', PACKAGE = 'mappoly2', input_data)
}

